import axios from 'axios';

// src/client.ts
var MessageStatus = /* @__PURE__ */ ((MessageStatus2) => {
  MessageStatus2["INFLIGHT"] = "INFLIGHT";
  MessageStatus2["DELIVERED"] = "DELIVERED";
  MessageStatus2["FAILED"] = "FAILED";
  return MessageStatus2;
})(MessageStatus || {});
var URLS = {
  testnet: "https://api-testnet.layerzero-scan.com",
  mainnet: "https://api-mainnet.layerzero-scan.com",
  sandbox: "https://api-sandbox.layerzero-scan.com"
};
var createClient = (env, options) => {
  const url = URLS[env];
  if (!url)
    throw new Error(`No endpoint for env ${env}`);
  const client = axios.create({
    baseURL: url
  });
  return {
    async getMessagesBySrcTxHash(srcTxHash) {
      if (!srcTxHash)
        throw new Error("srcTxHash must be provided");
      const { data } = await client.get(`/tx/${srcTxHash}`);
      return data;
    }
  };
};
function getMessagesBySrcTxHash(srcChainId, srcTxHash) {
  const env = srcChainId < 1e4 ? "mainnet" : srcChainId < 2e4 ? "testnet" : "sandbox";
  return createClient(env).getMessagesBySrcTxHash(srcTxHash);
}
async function waitForMessageReceived(srcChainId, srcTxHash, pollInterval = 3e3) {
  const env = srcChainId < 1e4 ? "mainnet" : srcChainId < 2e4 ? "testnet" : "sandbox";
  const client = createClient(env);
  while (true) {
    try {
      const { messages } = await client.getMessagesBySrcTxHash(srcTxHash);
      const message = messages[0];
      if (messages.length > 1) {
        return Promise.reject(new Error(`More than one message`));
      } else if ((message == null ? void 0 : message.status) === "FAILED" /* FAILED */) {
        return Promise.reject(new Error(`Message failed ${message.dstTxError}`));
      } else if ((message == null ? void 0 : message.status) === "DELIVERED" /* DELIVERED */) {
        return message;
      }
    } catch (e) {
    }
    await sleep(pollInterval);
  }
}
async function waitForAllMessagesReceived(srcChainId, srcTxHash, pollInterval = 3e3, numberOfMessages) {
  const env = srcChainId < 1e4 ? "mainnet" : srcChainId < 2e4 ? "testnet" : "sandbox";
  const client = createClient(env);
  while (true) {
    try {
      const { messages } = await client.getMessagesBySrcTxHash(srcTxHash);
      if (messages.length > 0) {
        if (messages.every((m) => m.status === "DELIVERED" /* DELIVERED */)) {
          if (numberOfMessages === void 0 || numberOfMessages === messages.length) {
            return messages;
          }
        }
      }
    } catch (e) {
    }
    await sleep(pollInterval);
  }
}
var sleep = (ms = 1e3) => new Promise((resolve) => setTimeout(resolve, ms));

export { MessageStatus, createClient, getMessagesBySrcTxHash, waitForAllMessagesReceived, waitForMessageReceived };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=client.mjs.map