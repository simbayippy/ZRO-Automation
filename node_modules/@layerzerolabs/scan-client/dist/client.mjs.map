{"version":3,"sources":["../src/client.ts"],"names":["MessageStatus"],"mappings":";AAAA,OAAO,WAAW;AAMX,IAAK,gBAAL,kBAAKA,mBAAL;AACL,EAAAA,eAAA,cAAW;AACX,EAAAA,eAAA,eAAY;AACZ,EAAAA,eAAA,YAAS;AAHC,SAAAA;AAAA,GAAA;AAoBZ,IAAM,OAAoC;AAAA,EACxC,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AACX;AAMO,IAAM,eAAe,CAAC,KAAkB,YAA4B;AACzE,QAAM,MAAM,KAAK,GAAG;AACpB,MAAI,CAAC;AAAK,UAAM,IAAI,MAAM,uBAAuB,KAAK;AAEtD,QAAM,SAAS,MAAM,OAAO;AAAA,IAC1B,SAAS;AAAA,EACX,CAAC;AAED,SAAO;AAAA,IACL,MAAM,uBAAuB,WAAmB;AAC9C,UAAI,CAAC;AAAW,cAAM,IAAI,MAAM,4BAA4B;AAC5D,YAAM,EAAC,KAAI,IAAI,MAAM,OAAO,IAAoC,OAAO,WAAW;AAClF,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEO,SAAS,uBAAuB,YAAoB,WAAmB;AAC5E,QAAM,MAAM,aAAa,MAAQ,YAAY,aAAa,MAAQ,YAAY;AAC9E,SAAO,aAAa,GAAG,EAAE,uBAAuB,SAAS;AAC3D;AAIA,eAAsB,uBACpB,YACA,WACA,eAAe,KACY;AAC3B,QAAM,MAAM,aAAa,MAAQ,YAAY,aAAa,MAAQ,YAAY;AAC9E,QAAM,SAAS,aAAa,GAAG;AAC/B,SAAO,MAAM;AACX,QAAI;AACF,YAAM,EAAC,SAAQ,IAAI,MAAM,OAAO,uBAAuB,SAAS;AAChE,YAAM,UAAU,SAAS,CAAC;AAC1B,UAAI,SAAS,SAAS,GAAG;AACvB,eAAO,QAAQ,OAAO,IAAI,MAAM,uBAAuB,CAAC;AAAA,MAC1D,YAAW,mCAAS,YAAW,uBAAsB;AACnD,eAAO,QAAQ,OAAO,IAAI,MAAM,kBAAkB,QAAQ,YAAY,CAAC;AAAA,MACzE,YAAW,mCAAS,YAAW,6BAAyB;AACtD,eAAO;AAAA,MACT;AAAA,IACF,SAAQ,GAAN;AAAA,IAEF;AACA,UAAM,MAAM,YAAY;AAAA,EAC1B;AACF;AAEA,eAAsB,2BACpB,YACA,WACA,eAAe,KACf,kBAC6B;AAC7B,QAAM,MAAM,aAAa,MAAQ,YAAY,aAAa,MAAQ,YAAY;AAC9E,QAAM,SAAS,aAAa,GAAG;AAC/B,SAAO,MAAM;AACX,QAAI;AACF,YAAM,EAAC,SAAQ,IAAI,MAAM,OAAO,uBAAuB,SAAS;AAChE,UAAI,SAAS,SAAS,GAAG;AACvB,YAAI,SAAS,MAAM,CAAC,MAAM,EAAE,WAAW,2BAAuB,GAAG;AAC/D,cAAI,qBAAqB,UAAa,qBAAqB,SAAS,QAAQ;AAC1E,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAQ,GAAN;AAAA,IAEF;AACA,UAAM,MAAM,YAAY;AAAA,EAC1B;AACF;AAEA,IAAM,QAAQ,CAAC,KAAK,QAAS,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC","sourcesContent":["import axios from 'axios';\n\nexport type Environment = 'testnet' | 'mainnet' | 'sandbox';\n\nexport type ClientOptions = {};\n\nexport enum MessageStatus {\n  INFLIGHT = 'INFLIGHT',\n  DELIVERED = 'DELIVERED',\n  FAILED = 'FAILED',\n}\n\nexport type Message = {\n  srcUaAddress: string;\n  dstUaAddress: string;\n  srcChainId: number;\n  dstChainId: number;\n  dstTxHash?: string;\n  dstTxError?: string;\n  srcTxHash?: string;\n  srcBlockHash?: string;\n  srcBlockNumber?: string;\n  srcUaNonce: number;\n  status: MessageStatus;\n};\n\nconst URLS: Record<Environment, string> = {\n  testnet: 'https://api-testnet.layerzero-scan.com',\n  mainnet: 'https://api-mainnet.layerzero-scan.com',\n  sandbox: 'https://api-sandbox.layerzero-scan.com',\n};\n\ntype GetMessagesBySrcTxHashResponse = {\n  messages: Message[];\n};\n\nexport const createClient = (env: Environment, options?: ClientOptions) => {\n  const url = URLS[env];\n  if (!url) throw new Error(`No endpoint for env ${env}`);\n\n  const client = axios.create({\n    baseURL: url,\n  });\n\n  return {\n    async getMessagesBySrcTxHash(srcTxHash: string) {\n      if (!srcTxHash) throw new Error('srcTxHash must be provided');\n      const {data} = await client.get<GetMessagesBySrcTxHashResponse>(`/tx/${srcTxHash}`);\n      return data;\n    },\n  };\n};\n\nexport function getMessagesBySrcTxHash(srcChainId: number, srcTxHash: string) {\n  const env = srcChainId < 10000 ? 'mainnet' : srcChainId < 20000 ? 'testnet' : 'sandbox';\n  return createClient(env).getMessagesBySrcTxHash(srcTxHash);\n}\n\ntype DeliveredMessage = Message & {dstTxHash: string};\n\nexport async function waitForMessageReceived(\n  srcChainId: number,\n  srcTxHash: string,\n  pollInterval = 3000,\n): Promise<DeliveredMessage> {\n  const env = srcChainId < 10000 ? 'mainnet' : srcChainId < 20000 ? 'testnet' : 'sandbox';\n  const client = createClient(env);\n  while (true) {\n    try {\n      const {messages} = await client.getMessagesBySrcTxHash(srcTxHash);\n      const message = messages[0];\n      if (messages.length > 1) {\n        return Promise.reject(new Error(`More than one message`));\n      } else if (message?.status === MessageStatus.FAILED) {\n        return Promise.reject(new Error(`Message failed ${message.dstTxError}`));\n      } else if (message?.status === MessageStatus.DELIVERED) {\n        return message as DeliveredMessage;\n      }\n    } catch {\n      // http error\n    }\n    await sleep(pollInterval);\n  }\n}\n\nexport async function waitForAllMessagesReceived(\n  srcChainId: number,\n  srcTxHash: string,\n  pollInterval = 3000,\n  numberOfMessages?: number,\n): Promise<DeliveredMessage[]> {\n  const env = srcChainId < 10000 ? 'mainnet' : srcChainId < 20000 ? 'testnet' : 'sandbox';\n  const client = createClient(env);\n  while (true) {\n    try {\n      const {messages} = await client.getMessagesBySrcTxHash(srcTxHash);\n      if (messages.length > 0) {\n        if (messages.every((m) => m.status === MessageStatus.DELIVERED)) {\n          if (numberOfMessages === undefined || numberOfMessages === messages.length) {\n            return messages as DeliveredMessage[];\n          }\n        }\n      }\n    } catch {\n      // http error\n    }\n    await sleep(pollInterval);\n  }\n}\n\nconst sleep = (ms = 1000) => new Promise((resolve) => setTimeout(resolve, ms));\n"]}