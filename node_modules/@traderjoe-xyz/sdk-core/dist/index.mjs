// src/entities/fractions/fraction.ts
import invariant2 from "tiny-invariant";
import JSBI3 from "jsbi";
import _Decimal from "decimal.js-light";
import _Big from "big.js";
import toFormat from "toformat";

// src/constants.ts
import JSBI from "jsbi";
var ChainId = /* @__PURE__ */ ((ChainId2) => {
  ChainId2[ChainId2["FUJI"] = 43113] = "FUJI";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARB_GOERLI"] = 421613] = "ARB_GOERLI";
  ChainId2[ChainId2["BNB_CHAIN"] = 56] = "BNB_CHAIN";
  ChainId2[ChainId2["BNB_TESTNET"] = 97] = "BNB_TESTNET";
  ChainId2[ChainId2["ETHEREUM"] = 1] = "ETHEREUM";
  return ChainId2;
})(ChainId || {});
var TradeType = /* @__PURE__ */ ((TradeType2) => {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
  return TradeType2;
})(TradeType || {});
var Rounding = /* @__PURE__ */ ((Rounding4) => {
  Rounding4[Rounding4["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding4[Rounding4["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding4[Rounding4["ROUND_UP"] = 2] = "ROUND_UP";
  return Rounding4;
})(Rounding || {});
var MINIMUM_LIQUIDITY = JSBI.BigInt(1e3);
var ZERO = JSBI.BigInt(0);
var ONE = JSBI.BigInt(1);
var TWO = JSBI.BigInt(2);
var THREE = JSBI.BigInt(3);
var FIVE = JSBI.BigInt(5);
var TEN = JSBI.BigInt(10);
var _100 = JSBI.BigInt(100);
var _997 = JSBI.BigInt(997);
var _1000 = JSBI.BigInt(1e3);
var SolidityType = /* @__PURE__ */ ((SolidityType2) => {
  SolidityType2["uint8"] = "uint8";
  SolidityType2["uint256"] = "uint256";
  return SolidityType2;
})(SolidityType || {});
var SOLIDITY_TYPE_MAXIMA = {
  ["uint8" /* uint8 */]: JSBI.BigInt("0xff"),
  ["uint256" /* uint256 */]: JSBI.BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  )
};

// src/utils.ts
import invariant from "tiny-invariant";
import warning from "tiny-warning";
import JSBI2 from "jsbi";
import { getAddress } from "viem";
function validateSolidityTypeInstance(value, solidityType) {
  invariant(
    JSBI2.greaterThanOrEqual(value, ZERO),
    `${value} is not a ${solidityType}.`
  );
  invariant(
    JSBI2.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]),
    `${value} is not a ${solidityType}.`
  );
}
function validateAndParseAddress(address) {
  try {
    const checksummedAddress = getAddress(address);
    warning(address === checksummedAddress, `${address} is not checksummed.`);
    return checksummedAddress;
  } catch (error) {
    console.error(error);
    invariant(false, `${address} is not a valid address.`);
  }
}
function parseBigintIsh(bigintIsh) {
  return bigintIsh instanceof JSBI2 ? bigintIsh : typeof bigintIsh === "bigint" ? JSBI2.BigInt(bigintIsh.toString()) : JSBI2.BigInt(bigintIsh);
}
function sqrt(y) {
  validateSolidityTypeInstance(y, "uint256" /* uint256 */);
  let z = ZERO;
  let x;
  if (JSBI2.greaterThan(y, THREE)) {
    z = y;
    x = JSBI2.add(JSBI2.divide(y, TWO), ONE);
    while (JSBI2.lessThan(x, z)) {
      z = x;
      x = JSBI2.divide(JSBI2.add(JSBI2.divide(y, x), x), TWO);
    }
  } else if (JSBI2.notEqual(y, ZERO)) {
    z = ONE;
  }
  return z;
}
function sortedInsert(items, add, maxSize, comparator) {
  invariant(maxSize > 0, "MAX_SIZE_ZERO");
  invariant(items.length <= maxSize, "ITEMS_SIZE");
  if (items.length === 0) {
    items.push(add);
    return null;
  } else {
    const isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add) <= 0) {
      return add;
    }
    let lo = 0, hi = items.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (comparator(items[mid], add) <= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    items.splice(lo, 0, add);
    return isFull ? items.pop() : null;
  }
}

// src/entities/fractions/fraction.ts
var Decimal = toFormat(_Decimal);
var Big = toFormat(_Big);
var toSignificantRounding = {
  [0 /* ROUND_DOWN */]: Decimal.ROUND_DOWN,
  [1 /* ROUND_HALF_UP */]: Decimal.ROUND_HALF_UP,
  [2 /* ROUND_UP */]: Decimal.ROUND_UP
};
var toFixedRounding = {
  [0 /* ROUND_DOWN */]: Big.roundDown,
  [1 /* ROUND_HALF_UP */]: Big.roundHalfUp,
  [2 /* ROUND_UP */]: Big.roundUp
};
var Fraction = class _Fraction {
  constructor(numerator, denominator = ONE) {
    this.numerator = parseBigintIsh(numerator);
    this.denominator = parseBigintIsh(denominator);
  }
  // performs floor division
  get quotient() {
    return JSBI3.divide(this.numerator, this.denominator);
  }
  // remainder after floor division
  get remainder() {
    return new _Fraction(
      JSBI3.remainder(this.numerator, this.denominator),
      this.denominator
    );
  }
  invert() {
    return new _Fraction(this.denominator, this.numerator);
  }
  add(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    if (JSBI3.equal(this.denominator, otherParsed.denominator)) {
      return new _Fraction(
        JSBI3.add(this.numerator, otherParsed.numerator),
        this.denominator
      );
    }
    return new _Fraction(
      JSBI3.add(
        JSBI3.multiply(this.numerator, otherParsed.denominator),
        JSBI3.multiply(otherParsed.numerator, this.denominator)
      ),
      JSBI3.multiply(this.denominator, otherParsed.denominator)
    );
  }
  subtract(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    if (JSBI3.equal(this.denominator, otherParsed.denominator)) {
      return new _Fraction(
        JSBI3.subtract(this.numerator, otherParsed.numerator),
        this.denominator
      );
    }
    return new _Fraction(
      JSBI3.subtract(
        JSBI3.multiply(this.numerator, otherParsed.denominator),
        JSBI3.multiply(otherParsed.numerator, this.denominator)
      ),
      JSBI3.multiply(this.denominator, otherParsed.denominator)
    );
  }
  lessThan(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return JSBI3.lessThan(
      JSBI3.multiply(this.numerator, otherParsed.denominator),
      JSBI3.multiply(otherParsed.numerator, this.denominator)
    );
  }
  equalTo(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return JSBI3.equal(
      JSBI3.multiply(this.numerator, otherParsed.denominator),
      JSBI3.multiply(otherParsed.numerator, this.denominator)
    );
  }
  greaterThan(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return JSBI3.greaterThan(
      JSBI3.multiply(this.numerator, otherParsed.denominator),
      JSBI3.multiply(otherParsed.numerator, this.denominator)
    );
  }
  multiply(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return new _Fraction(
      JSBI3.multiply(this.numerator, otherParsed.numerator),
      JSBI3.multiply(this.denominator, otherParsed.denominator)
    );
  }
  divide(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return new _Fraction(
      JSBI3.multiply(this.numerator, otherParsed.denominator),
      JSBI3.multiply(this.denominator, otherParsed.numerator)
    );
  }
  toSignificant(significantDigits, format = { groupSeparator: "" }, rounding = 1 /* ROUND_HALF_UP */) {
    invariant2(
      Number.isInteger(significantDigits),
      `${significantDigits} is not an integer.`
    );
    invariant2(significantDigits > 0, `${significantDigits} is not positive.`);
    Decimal.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    const quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  }
  toFixed(decimalPlaces, format = { groupSeparator: "" }, rounding = 1 /* ROUND_HALF_UP */) {
    invariant2(
      Number.isInteger(decimalPlaces),
      `${decimalPlaces} is not an integer.`
    );
    invariant2(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
};

// src/entities/fractions/percent.ts
var _100_PERCENT = new Fraction(_100);
var Percent = class extends Fraction {
  toSignificant(significantDigits = 5, format, rounding) {
    return this.multiply(_100_PERCENT).toSignificant(
      significantDigits,
      format,
      rounding
    );
  }
  toFixed(decimalPlaces = 2, format, rounding) {
    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding);
  }
};

// src/entities/token.ts
import invariant3 from "tiny-invariant";
var Token = class {
  constructor(chainId, address, decimals, symbol, name) {
    this.isNative = false;
    this.isToken = true;
    this.chainId = chainId;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
    this.address = validateAndParseAddress(address);
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
   * @param other other token to compare
   */
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.chainId === other.chainId && this.address === other.address;
  }
  /**
   * Returns true if the address of this token sorts before the address of the other token
   * @param other other token to compare
   * @throws if the tokens have the same address
   * @throws if the tokens are on different chains
   */
  sortsBefore(other) {
    invariant3(this.chainId === other.chainId, "CHAIN_IDS");
    invariant3(this.address !== other.address, "ADDRESSES");
    return this.address.toLowerCase() < other.address.toLowerCase();
  }
};
function currencyEquals(currencyA, currencyB) {
  if (currencyA instanceof Token && currencyB instanceof Token) {
    return currencyA.equals(currencyB);
  } else if (currencyA instanceof Token) {
    return false;
  } else if (currencyB instanceof Token) {
    return false;
  } else {
    return currencyA === currencyB;
  }
}
var WNATIVE = {
  [43113 /* FUJI */]: new Token(
    43113 /* FUJI */,
    "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
    18,
    "WAVAX",
    "Wrapped AVAX"
  ),
  [43114 /* AVALANCHE */]: new Token(
    43114 /* AVALANCHE */,
    "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    18,
    "WAVAX",
    "Wrapped AVAX"
  ),
  [42161 /* ARBITRUM_ONE */]: new Token(
    42161 /* ARBITRUM_ONE */,
    "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    18,
    "WETH",
    "Wrapped ETH"
  ),
  [421613 /* ARB_GOERLI */]: new Token(
    421613 /* ARB_GOERLI */,
    "0xaE4EC9901c3076D0DdBe76A520F9E90a6227aCB7",
    18,
    "WETH",
    "Wrapped ETH"
  ),
  [56 /* BNB_CHAIN */]: new Token(
    56 /* BNB_CHAIN */,
    "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    18,
    "WBNB",
    "Wrapped BNB"
  ),
  [97 /* BNB_TESTNET */]: new Token(
    97 /* BNB_TESTNET */,
    "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
    18,
    "WBNB",
    "Wrapped BNB"
  ),
  [1 /* ETHEREUM */]: new Token(
    1 /* ETHEREUM */,
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    18,
    "WETH",
    "Wrapped ETH"
  )
};
var WAVAX = WNATIVE;

// src/entities/currency.ts
import JSBI4 from "jsbi";
var NativeCurrency = class {
  /**
   * Constructs an instance of the base class `NativeCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  constructor(chainId, decimals, symbol, name) {
    this.isNative = true;
    this.isToken = false;
    validateSolidityTypeInstance(JSBI4.BigInt(decimals), "uint8" /* uint8 */);
    this.chainId = chainId;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
  }
  equals(other) {
    return other.isNative && other.chainId === this.chainId;
  }
};
var _CNATIVE = class _CNATIVE extends NativeCurrency {
  constructor(chainId) {
    const symbol = [43113, 43114].includes(chainId) ? "AVAX" : 56 === chainId ? "BNB" : 97 === chainId ? "tBNB" : "ETH";
    const name = [43113, 43114].includes(chainId) ? "Avalanche" : [56, 97].includes(chainId) ? "BNB" : "Ethereum";
    super(chainId, 18, symbol, name);
  }
  equals(other) {
    return other.isNative && other.chainId === this.chainId;
  }
  static onChain(chainId) {
    var _a;
    return (_a = this._etherCache[chainId]) != null ? _a : this._etherCache[chainId] = new _CNATIVE(chainId);
  }
};
_CNATIVE._etherCache = {};
var CNATIVE = _CNATIVE;
var CAVAX = CNATIVE.onChain(43114);

// src/entities/fractions/currencyAmount.ts
import invariant4 from "tiny-invariant";
import JSBI5 from "jsbi";
import _Big2 from "big.js";
import toFormat2 from "toformat";
var Big2 = toFormat2(_Big2);
var CurrencyAmount = class _CurrencyAmount extends Fraction {
  // amount _must_ be raw, i.e. in the native representation
  constructor(currency, amount) {
    const parsedAmount = parseBigintIsh(amount);
    validateSolidityTypeInstance(parsedAmount, "uint256" /* uint256 */);
    super(parsedAmount, JSBI5.exponentiate(TEN, JSBI5.BigInt(currency.decimals)));
    this.currency = currency;
  }
  /**
   * Helper that calls the constructor with the CNATIVE currency
   * @param chainId the chain on which the CNATIVE exists
   * @param rawAmount CNATIVE amount in wei
   */
  static ether(chainId, amount) {
    return new _CurrencyAmount(CNATIVE.onChain(chainId), amount);
  }
  get raw() {
    return this.numerator;
  }
  add(other) {
    invariant4(currencyEquals(this.currency, other.currency), "TOKEN");
    return new _CurrencyAmount(this.currency, JSBI5.add(this.raw, other.raw));
  }
  subtract(other) {
    invariant4(currencyEquals(this.currency, other.currency), "TOKEN");
    return new _CurrencyAmount(this.currency, JSBI5.subtract(this.raw, other.raw));
  }
  toSignificant(significantDigits = 6, format, rounding = 0 /* ROUND_DOWN */) {
    return super.toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = this.currency.decimals, format, rounding = 0 /* ROUND_DOWN */) {
    invariant4(decimalPlaces <= this.currency.decimals, "DECIMALS");
    return super.toFixed(decimalPlaces, format, rounding);
  }
  toExact(format = { groupSeparator: "" }) {
    Big2.DP = this.currency.decimals;
    return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
  }
};

// src/entities/fractions/tokenAmount.ts
import invariant5 from "tiny-invariant";
import JSBI6 from "jsbi";
var TokenAmount = class _TokenAmount extends CurrencyAmount {
  // amount _must_ be raw, i.e. in the native representation
  constructor(token, amount) {
    super(token, amount);
    this.token = token;
  }
  add(other) {
    invariant5(this.token.equals(other.token), "TOKEN");
    return new _TokenAmount(this.token, JSBI6.add(this.raw, other.raw));
  }
  subtract(other) {
    invariant5(this.token.equals(other.token), "TOKEN");
    return new _TokenAmount(this.token, JSBI6.subtract(this.raw, other.raw));
  }
};

// src/entities/price.ts
import invariant6 from "tiny-invariant";
import JSBI7 from "jsbi";
var Price = class _Price extends Fraction {
  // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token
  // denominator and numerator _must_ be raw, i.e. in the native representation
  constructor(baseCurrency, quoteCurrency, denominator, numerator) {
    super(numerator, denominator);
    this.baseCurrency = baseCurrency;
    this.quoteCurrency = quoteCurrency;
    this.scalar = new Fraction(
      JSBI7.exponentiate(TEN, JSBI7.BigInt(baseCurrency.decimals)),
      JSBI7.exponentiate(TEN, JSBI7.BigInt(quoteCurrency.decimals))
    );
  }
  get raw() {
    return new Fraction(this.numerator, this.denominator);
  }
  get adjusted() {
    return super.multiply(this.scalar);
  }
  invert() {
    return new _Price(
      this.quoteCurrency,
      this.baseCurrency,
      this.numerator,
      this.denominator
    );
  }
  multiply(other) {
    invariant6(currencyEquals(this.quoteCurrency, other.baseCurrency), "TOKEN");
    const fraction = super.multiply(other);
    return new _Price(
      this.baseCurrency,
      other.quoteCurrency,
      fraction.denominator,
      fraction.numerator
    );
  }
  // performs floor division on overflow
  quote(currencyAmount) {
    invariant6(
      currencyEquals(currencyAmount.currency, this.baseCurrency),
      "TOKEN"
    );
    if (this.quoteCurrency instanceof Token) {
      return new TokenAmount(
        this.quoteCurrency,
        super.multiply(currencyAmount.raw).quotient
      );
    }
    return CurrencyAmount.ether(
      currencyAmount.currency.chainId,
      super.multiply(currencyAmount.raw).quotient
    );
  }
  toSignificant(significantDigits = 6, format, rounding) {
    return this.adjusted.toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = 4, format, rounding) {
    return this.adjusted.toFixed(decimalPlaces, format, rounding);
  }
};
export {
  CAVAX,
  CNATIVE,
  ChainId,
  CurrencyAmount,
  FIVE,
  Fraction,
  MINIMUM_LIQUIDITY,
  NativeCurrency,
  ONE,
  Percent,
  Price,
  Rounding,
  SOLIDITY_TYPE_MAXIMA,
  SolidityType,
  TEN,
  THREE,
  TWO,
  Token,
  TokenAmount,
  TradeType,
  WAVAX,
  WNATIVE,
  ZERO,
  _100,
  _1000,
  _997,
  currencyEquals,
  parseBigintIsh,
  sortedInsert,
  sqrt,
  validateAndParseAddress,
  validateSolidityTypeInstance
};
