import JSBI from 'jsbi';

type BigintIsh = JSBI | bigint | string;
declare enum ChainId {
    FUJI = 43113,
    AVALANCHE = 43114,
    ARBITRUM_ONE = 42161,
    ARB_GOERLI = 421613,
    BNB_CHAIN = 56,
    BNB_TESTNET = 97,
    ETHEREUM = 1
}
declare enum TradeType {
    EXACT_INPUT = 0,
    EXACT_OUTPUT = 1
}
declare enum Rounding {
    ROUND_DOWN = 0,
    ROUND_HALF_UP = 1,
    ROUND_UP = 2
}
declare const MINIMUM_LIQUIDITY: JSBI;
declare const ZERO: JSBI;
declare const ONE: JSBI;
declare const TWO: JSBI;
declare const THREE: JSBI;
declare const FIVE: JSBI;
declare const TEN: JSBI;
declare const _100: JSBI;
declare const _997: JSBI;
declare const _1000: JSBI;
declare enum SolidityType {
    uint8 = "uint8",
    uint256 = "uint256"
}
declare const SOLIDITY_TYPE_MAXIMA: {
    uint8: JSBI;
    uint256: JSBI;
};

declare class Fraction {
    readonly numerator: JSBI;
    readonly denominator: JSBI;
    constructor(numerator: BigintIsh, denominator?: BigintIsh);
    get quotient(): JSBI;
    get remainder(): Fraction;
    invert(): Fraction;
    add(other: Fraction | BigintIsh): Fraction;
    subtract(other: Fraction | BigintIsh): Fraction;
    lessThan(other: Fraction | BigintIsh): boolean;
    equalTo(other: Fraction | BigintIsh): boolean;
    greaterThan(other: Fraction | BigintIsh): boolean;
    multiply(other: Fraction | BigintIsh): Fraction;
    divide(other: Fraction | BigintIsh): Fraction;
    toSignificant(significantDigits: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces: number, format?: object, rounding?: Rounding): string;
}

declare class Percent extends Fraction {
    toSignificant(significantDigits?: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: object, rounding?: Rounding): string;
}

/**
 * Represents an ERC20 token with a unique address and some metadata.
 */
declare class Token {
    readonly decimals: number;
    readonly symbol?: string;
    readonly name?: string;
    readonly isNative: false;
    readonly isToken: true;
    readonly chainId: number;
    /**
     * The contract address on the chain on which this token lives
     */
    readonly address: string;
    constructor(chainId: ChainId, address: string, decimals: number, symbol?: string, name?: string);
    /**
     * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
     * @param other other token to compare
     */
    equals(other: Token): boolean;
    /**
     * Returns true if the address of this token sorts before the address of the other token
     * @param other other token to compare
     * @throws if the tokens have the same address
     * @throws if the tokens are on different chains
     */
    sortsBefore(other: Token): boolean;
}
/**
 * Compares two currencies for equality
 */
declare function currencyEquals(currencyA: Currency, currencyB: Currency): boolean;
declare const WNATIVE: {
    43113: Token;
    43114: Token;
    42161: Token;
    421613: Token;
    56: Token;
    97: Token;
    1: Token;
};
declare const WAVAX: {
    43113: Token;
    43114: Token;
    42161: Token;
    421613: Token;
    56: Token;
    97: Token;
    1: Token;
};

/**
 * Represents the native currency of the chain on which it resides, e.g. ETH, AVAX
 */
declare class NativeCurrency {
    readonly decimals: number;
    readonly symbol?: string;
    readonly name?: string;
    readonly isNative: true;
    readonly isToken: false;
    readonly chainId: number;
    /**
     * Constructs an instance of the base class `NativeCurrency`.
     * @param chainId the chain ID on which this currency resides
     * @param decimals decimals of the currency
     * @param symbol symbol of the currency
     * @param name of the currency
     */
    constructor(chainId: number, decimals: number, symbol?: string, name?: string);
    equals(other: NativeCurrency): boolean;
}
declare class CNATIVE extends NativeCurrency {
    constructor(chainId: number);
    equals(other: NativeCurrency): boolean;
    private static _etherCache;
    static onChain(chainId: number): CNATIVE;
}
/**
 * for backward compatibility
 */
declare const CAVAX: CNATIVE;

/**
 * A currency is any fungible financial instrument, including Ether, all ERC20 tokens, and other chain-native currencies
 */
type Currency = NativeCurrency | Token;

declare class CurrencyAmount extends Fraction {
    readonly currency: Currency;
    /**
     * Helper that calls the constructor with the CNATIVE currency
     * @param chainId the chain on which the CNATIVE exists
     * @param rawAmount CNATIVE amount in wei
     */
    static ether(chainId: number, amount: BigintIsh): CurrencyAmount;
    protected constructor(currency: Currency, amount: BigintIsh);
    get raw(): JSBI;
    add(other: CurrencyAmount): CurrencyAmount;
    subtract(other: CurrencyAmount): CurrencyAmount;
    toSignificant(significantDigits?: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: object, rounding?: Rounding): string;
    toExact(format?: object): string;
}

declare class TokenAmount extends CurrencyAmount {
    readonly token: Token;
    constructor(token: Token, amount: BigintIsh);
    add(other: TokenAmount): TokenAmount;
    subtract(other: TokenAmount): TokenAmount;
}

declare class Price extends Fraction {
    readonly baseCurrency: Currency;
    readonly quoteCurrency: Currency;
    readonly scalar: Fraction;
    constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh);
    get raw(): Fraction;
    get adjusted(): Fraction;
    invert(): Price;
    multiply(other: Price): Price;
    quote(currencyAmount: CurrencyAmount): CurrencyAmount;
    toSignificant(significantDigits?: number, format?: object, rounding?: Rounding): string;
    toFixed(decimalPlaces?: number, format?: object, rounding?: Rounding): string;
}

declare function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void;
declare function validateAndParseAddress(address: string): string;
declare function parseBigintIsh(bigintIsh: BigintIsh): JSBI;
declare function sqrt(y: JSBI): JSBI;
declare function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null;

export { BigintIsh, CAVAX, CNATIVE, ChainId, Currency, CurrencyAmount, FIVE, Fraction, MINIMUM_LIQUIDITY, NativeCurrency, ONE, Percent, Price, Rounding, SOLIDITY_TYPE_MAXIMA, SolidityType, TEN, THREE, TWO, Token, TokenAmount, TradeType, WAVAX, WNATIVE, ZERO, _100, _1000, _997, currencyEquals, parseBigintIsh, sortedInsert, sqrt, validateAndParseAddress, validateSolidityTypeInstance };
