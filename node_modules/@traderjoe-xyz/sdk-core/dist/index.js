"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CAVAX: () => CAVAX,
  CNATIVE: () => CNATIVE,
  ChainId: () => ChainId,
  CurrencyAmount: () => CurrencyAmount,
  FIVE: () => FIVE,
  Fraction: () => Fraction,
  MINIMUM_LIQUIDITY: () => MINIMUM_LIQUIDITY,
  NativeCurrency: () => NativeCurrency,
  ONE: () => ONE,
  Percent: () => Percent,
  Price: () => Price,
  Rounding: () => Rounding,
  SOLIDITY_TYPE_MAXIMA: () => SOLIDITY_TYPE_MAXIMA,
  SolidityType: () => SolidityType,
  TEN: () => TEN,
  THREE: () => THREE,
  TWO: () => TWO,
  Token: () => Token,
  TokenAmount: () => TokenAmount,
  TradeType: () => TradeType,
  WAVAX: () => WAVAX,
  WNATIVE: () => WNATIVE,
  ZERO: () => ZERO,
  _100: () => _100,
  _1000: () => _1000,
  _997: () => _997,
  currencyEquals: () => currencyEquals,
  parseBigintIsh: () => parseBigintIsh,
  sortedInsert: () => sortedInsert,
  sqrt: () => sqrt,
  validateAndParseAddress: () => validateAndParseAddress,
  validateSolidityTypeInstance: () => validateSolidityTypeInstance
});
module.exports = __toCommonJS(src_exports);

// src/entities/fractions/fraction.ts
var import_tiny_invariant2 = __toESM(require("tiny-invariant"));
var import_jsbi3 = __toESM(require("jsbi"));
var import_decimal = __toESM(require("decimal.js-light"));
var import_big = __toESM(require("big.js"));
var import_toformat = __toESM(require("toformat"));

// src/constants.ts
var import_jsbi = __toESM(require("jsbi"));
var ChainId = /* @__PURE__ */ ((ChainId2) => {
  ChainId2[ChainId2["FUJI"] = 43113] = "FUJI";
  ChainId2[ChainId2["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId2[ChainId2["ARBITRUM_ONE"] = 42161] = "ARBITRUM_ONE";
  ChainId2[ChainId2["ARB_GOERLI"] = 421613] = "ARB_GOERLI";
  ChainId2[ChainId2["BNB_CHAIN"] = 56] = "BNB_CHAIN";
  ChainId2[ChainId2["BNB_TESTNET"] = 97] = "BNB_TESTNET";
  ChainId2[ChainId2["ETHEREUM"] = 1] = "ETHEREUM";
  return ChainId2;
})(ChainId || {});
var TradeType = /* @__PURE__ */ ((TradeType2) => {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
  return TradeType2;
})(TradeType || {});
var Rounding = /* @__PURE__ */ ((Rounding4) => {
  Rounding4[Rounding4["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding4[Rounding4["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding4[Rounding4["ROUND_UP"] = 2] = "ROUND_UP";
  return Rounding4;
})(Rounding || {});
var MINIMUM_LIQUIDITY = import_jsbi.default.BigInt(1e3);
var ZERO = import_jsbi.default.BigInt(0);
var ONE = import_jsbi.default.BigInt(1);
var TWO = import_jsbi.default.BigInt(2);
var THREE = import_jsbi.default.BigInt(3);
var FIVE = import_jsbi.default.BigInt(5);
var TEN = import_jsbi.default.BigInt(10);
var _100 = import_jsbi.default.BigInt(100);
var _997 = import_jsbi.default.BigInt(997);
var _1000 = import_jsbi.default.BigInt(1e3);
var SolidityType = /* @__PURE__ */ ((SolidityType2) => {
  SolidityType2["uint8"] = "uint8";
  SolidityType2["uint256"] = "uint256";
  return SolidityType2;
})(SolidityType || {});
var SOLIDITY_TYPE_MAXIMA = {
  ["uint8" /* uint8 */]: import_jsbi.default.BigInt("0xff"),
  ["uint256" /* uint256 */]: import_jsbi.default.BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  )
};

// src/utils.ts
var import_tiny_invariant = __toESM(require("tiny-invariant"));
var import_tiny_warning = __toESM(require("tiny-warning"));
var import_jsbi2 = __toESM(require("jsbi"));
var import_viem = require("viem");
function validateSolidityTypeInstance(value, solidityType) {
  (0, import_tiny_invariant.default)(
    import_jsbi2.default.greaterThanOrEqual(value, ZERO),
    `${value} is not a ${solidityType}.`
  );
  (0, import_tiny_invariant.default)(
    import_jsbi2.default.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]),
    `${value} is not a ${solidityType}.`
  );
}
function validateAndParseAddress(address) {
  try {
    const checksummedAddress = (0, import_viem.getAddress)(address);
    (0, import_tiny_warning.default)(address === checksummedAddress, `${address} is not checksummed.`);
    return checksummedAddress;
  } catch (error) {
    console.error(error);
    (0, import_tiny_invariant.default)(false, `${address} is not a valid address.`);
  }
}
function parseBigintIsh(bigintIsh) {
  return bigintIsh instanceof import_jsbi2.default ? bigintIsh : typeof bigintIsh === "bigint" ? import_jsbi2.default.BigInt(bigintIsh.toString()) : import_jsbi2.default.BigInt(bigintIsh);
}
function sqrt(y) {
  validateSolidityTypeInstance(y, "uint256" /* uint256 */);
  let z = ZERO;
  let x;
  if (import_jsbi2.default.greaterThan(y, THREE)) {
    z = y;
    x = import_jsbi2.default.add(import_jsbi2.default.divide(y, TWO), ONE);
    while (import_jsbi2.default.lessThan(x, z)) {
      z = x;
      x = import_jsbi2.default.divide(import_jsbi2.default.add(import_jsbi2.default.divide(y, x), x), TWO);
    }
  } else if (import_jsbi2.default.notEqual(y, ZERO)) {
    z = ONE;
  }
  return z;
}
function sortedInsert(items, add, maxSize, comparator) {
  (0, import_tiny_invariant.default)(maxSize > 0, "MAX_SIZE_ZERO");
  (0, import_tiny_invariant.default)(items.length <= maxSize, "ITEMS_SIZE");
  if (items.length === 0) {
    items.push(add);
    return null;
  } else {
    const isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add) <= 0) {
      return add;
    }
    let lo = 0, hi = items.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (comparator(items[mid], add) <= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    items.splice(lo, 0, add);
    return isFull ? items.pop() : null;
  }
}

// src/entities/fractions/fraction.ts
var Decimal = (0, import_toformat.default)(import_decimal.default);
var Big = (0, import_toformat.default)(import_big.default);
var toSignificantRounding = {
  [0 /* ROUND_DOWN */]: Decimal.ROUND_DOWN,
  [1 /* ROUND_HALF_UP */]: Decimal.ROUND_HALF_UP,
  [2 /* ROUND_UP */]: Decimal.ROUND_UP
};
var toFixedRounding = {
  [0 /* ROUND_DOWN */]: Big.roundDown,
  [1 /* ROUND_HALF_UP */]: Big.roundHalfUp,
  [2 /* ROUND_UP */]: Big.roundUp
};
var Fraction = class _Fraction {
  constructor(numerator, denominator = ONE) {
    this.numerator = parseBigintIsh(numerator);
    this.denominator = parseBigintIsh(denominator);
  }
  // performs floor division
  get quotient() {
    return import_jsbi3.default.divide(this.numerator, this.denominator);
  }
  // remainder after floor division
  get remainder() {
    return new _Fraction(
      import_jsbi3.default.remainder(this.numerator, this.denominator),
      this.denominator
    );
  }
  invert() {
    return new _Fraction(this.denominator, this.numerator);
  }
  add(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    if (import_jsbi3.default.equal(this.denominator, otherParsed.denominator)) {
      return new _Fraction(
        import_jsbi3.default.add(this.numerator, otherParsed.numerator),
        this.denominator
      );
    }
    return new _Fraction(
      import_jsbi3.default.add(
        import_jsbi3.default.multiply(this.numerator, otherParsed.denominator),
        import_jsbi3.default.multiply(otherParsed.numerator, this.denominator)
      ),
      import_jsbi3.default.multiply(this.denominator, otherParsed.denominator)
    );
  }
  subtract(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    if (import_jsbi3.default.equal(this.denominator, otherParsed.denominator)) {
      return new _Fraction(
        import_jsbi3.default.subtract(this.numerator, otherParsed.numerator),
        this.denominator
      );
    }
    return new _Fraction(
      import_jsbi3.default.subtract(
        import_jsbi3.default.multiply(this.numerator, otherParsed.denominator),
        import_jsbi3.default.multiply(otherParsed.numerator, this.denominator)
      ),
      import_jsbi3.default.multiply(this.denominator, otherParsed.denominator)
    );
  }
  lessThan(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return import_jsbi3.default.lessThan(
      import_jsbi3.default.multiply(this.numerator, otherParsed.denominator),
      import_jsbi3.default.multiply(otherParsed.numerator, this.denominator)
    );
  }
  equalTo(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return import_jsbi3.default.equal(
      import_jsbi3.default.multiply(this.numerator, otherParsed.denominator),
      import_jsbi3.default.multiply(otherParsed.numerator, this.denominator)
    );
  }
  greaterThan(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return import_jsbi3.default.greaterThan(
      import_jsbi3.default.multiply(this.numerator, otherParsed.denominator),
      import_jsbi3.default.multiply(otherParsed.numerator, this.denominator)
    );
  }
  multiply(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return new _Fraction(
      import_jsbi3.default.multiply(this.numerator, otherParsed.numerator),
      import_jsbi3.default.multiply(this.denominator, otherParsed.denominator)
    );
  }
  divide(other) {
    const otherParsed = other instanceof _Fraction ? other : new _Fraction(parseBigintIsh(other));
    return new _Fraction(
      import_jsbi3.default.multiply(this.numerator, otherParsed.denominator),
      import_jsbi3.default.multiply(this.denominator, otherParsed.numerator)
    );
  }
  toSignificant(significantDigits, format = { groupSeparator: "" }, rounding = 1 /* ROUND_HALF_UP */) {
    (0, import_tiny_invariant2.default)(
      Number.isInteger(significantDigits),
      `${significantDigits} is not an integer.`
    );
    (0, import_tiny_invariant2.default)(significantDigits > 0, `${significantDigits} is not positive.`);
    Decimal.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    const quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  }
  toFixed(decimalPlaces, format = { groupSeparator: "" }, rounding = 1 /* ROUND_HALF_UP */) {
    (0, import_tiny_invariant2.default)(
      Number.isInteger(decimalPlaces),
      `${decimalPlaces} is not an integer.`
    );
    (0, import_tiny_invariant2.default)(decimalPlaces >= 0, `${decimalPlaces} is negative.`);
    Big.DP = decimalPlaces;
    Big.RM = toFixedRounding[rounding];
    return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  }
};

// src/entities/fractions/percent.ts
var _100_PERCENT = new Fraction(_100);
var Percent = class extends Fraction {
  toSignificant(significantDigits = 5, format, rounding) {
    return this.multiply(_100_PERCENT).toSignificant(
      significantDigits,
      format,
      rounding
    );
  }
  toFixed(decimalPlaces = 2, format, rounding) {
    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding);
  }
};

// src/entities/token.ts
var import_tiny_invariant3 = __toESM(require("tiny-invariant"));
var Token = class {
  constructor(chainId, address, decimals, symbol, name) {
    this.isNative = false;
    this.isToken = true;
    this.chainId = chainId;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
    this.address = validateAndParseAddress(address);
  }
  /**
   * Returns true if the two tokens are equivalent, i.e. have the same chainId and address.
   * @param other other token to compare
   */
  equals(other) {
    if (this === other) {
      return true;
    }
    return this.chainId === other.chainId && this.address === other.address;
  }
  /**
   * Returns true if the address of this token sorts before the address of the other token
   * @param other other token to compare
   * @throws if the tokens have the same address
   * @throws if the tokens are on different chains
   */
  sortsBefore(other) {
    (0, import_tiny_invariant3.default)(this.chainId === other.chainId, "CHAIN_IDS");
    (0, import_tiny_invariant3.default)(this.address !== other.address, "ADDRESSES");
    return this.address.toLowerCase() < other.address.toLowerCase();
  }
};
function currencyEquals(currencyA, currencyB) {
  if (currencyA instanceof Token && currencyB instanceof Token) {
    return currencyA.equals(currencyB);
  } else if (currencyA instanceof Token) {
    return false;
  } else if (currencyB instanceof Token) {
    return false;
  } else {
    return currencyA === currencyB;
  }
}
var WNATIVE = {
  [43113 /* FUJI */]: new Token(
    43113 /* FUJI */,
    "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
    18,
    "WAVAX",
    "Wrapped AVAX"
  ),
  [43114 /* AVALANCHE */]: new Token(
    43114 /* AVALANCHE */,
    "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    18,
    "WAVAX",
    "Wrapped AVAX"
  ),
  [42161 /* ARBITRUM_ONE */]: new Token(
    42161 /* ARBITRUM_ONE */,
    "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    18,
    "WETH",
    "Wrapped ETH"
  ),
  [421613 /* ARB_GOERLI */]: new Token(
    421613 /* ARB_GOERLI */,
    "0xaE4EC9901c3076D0DdBe76A520F9E90a6227aCB7",
    18,
    "WETH",
    "Wrapped ETH"
  ),
  [56 /* BNB_CHAIN */]: new Token(
    56 /* BNB_CHAIN */,
    "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    18,
    "WBNB",
    "Wrapped BNB"
  ),
  [97 /* BNB_TESTNET */]: new Token(
    97 /* BNB_TESTNET */,
    "0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd",
    18,
    "WBNB",
    "Wrapped BNB"
  ),
  [1 /* ETHEREUM */]: new Token(
    1 /* ETHEREUM */,
    "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    18,
    "WETH",
    "Wrapped ETH"
  )
};
var WAVAX = WNATIVE;

// src/entities/currency.ts
var import_jsbi4 = __toESM(require("jsbi"));
var NativeCurrency = class {
  /**
   * Constructs an instance of the base class `NativeCurrency`.
   * @param chainId the chain ID on which this currency resides
   * @param decimals decimals of the currency
   * @param symbol symbol of the currency
   * @param name of the currency
   */
  constructor(chainId, decimals, symbol, name) {
    this.isNative = true;
    this.isToken = false;
    validateSolidityTypeInstance(import_jsbi4.default.BigInt(decimals), "uint8" /* uint8 */);
    this.chainId = chainId;
    this.decimals = decimals;
    this.symbol = symbol;
    this.name = name;
  }
  equals(other) {
    return other.isNative && other.chainId === this.chainId;
  }
};
var _CNATIVE = class _CNATIVE extends NativeCurrency {
  constructor(chainId) {
    const symbol = [43113, 43114].includes(chainId) ? "AVAX" : 56 === chainId ? "BNB" : 97 === chainId ? "tBNB" : "ETH";
    const name = [43113, 43114].includes(chainId) ? "Avalanche" : [56, 97].includes(chainId) ? "BNB" : "Ethereum";
    super(chainId, 18, symbol, name);
  }
  equals(other) {
    return other.isNative && other.chainId === this.chainId;
  }
  static onChain(chainId) {
    var _a;
    return (_a = this._etherCache[chainId]) != null ? _a : this._etherCache[chainId] = new _CNATIVE(chainId);
  }
};
_CNATIVE._etherCache = {};
var CNATIVE = _CNATIVE;
var CAVAX = CNATIVE.onChain(43114);

// src/entities/fractions/currencyAmount.ts
var import_tiny_invariant4 = __toESM(require("tiny-invariant"));
var import_jsbi5 = __toESM(require("jsbi"));
var import_big2 = __toESM(require("big.js"));
var import_toformat2 = __toESM(require("toformat"));
var Big2 = (0, import_toformat2.default)(import_big2.default);
var CurrencyAmount = class _CurrencyAmount extends Fraction {
  // amount _must_ be raw, i.e. in the native representation
  constructor(currency, amount) {
    const parsedAmount = parseBigintIsh(amount);
    validateSolidityTypeInstance(parsedAmount, "uint256" /* uint256 */);
    super(parsedAmount, import_jsbi5.default.exponentiate(TEN, import_jsbi5.default.BigInt(currency.decimals)));
    this.currency = currency;
  }
  /**
   * Helper that calls the constructor with the CNATIVE currency
   * @param chainId the chain on which the CNATIVE exists
   * @param rawAmount CNATIVE amount in wei
   */
  static ether(chainId, amount) {
    return new _CurrencyAmount(CNATIVE.onChain(chainId), amount);
  }
  get raw() {
    return this.numerator;
  }
  add(other) {
    (0, import_tiny_invariant4.default)(currencyEquals(this.currency, other.currency), "TOKEN");
    return new _CurrencyAmount(this.currency, import_jsbi5.default.add(this.raw, other.raw));
  }
  subtract(other) {
    (0, import_tiny_invariant4.default)(currencyEquals(this.currency, other.currency), "TOKEN");
    return new _CurrencyAmount(this.currency, import_jsbi5.default.subtract(this.raw, other.raw));
  }
  toSignificant(significantDigits = 6, format, rounding = 0 /* ROUND_DOWN */) {
    return super.toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = this.currency.decimals, format, rounding = 0 /* ROUND_DOWN */) {
    (0, import_tiny_invariant4.default)(decimalPlaces <= this.currency.decimals, "DECIMALS");
    return super.toFixed(decimalPlaces, format, rounding);
  }
  toExact(format = { groupSeparator: "" }) {
    Big2.DP = this.currency.decimals;
    return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
  }
};

// src/entities/fractions/tokenAmount.ts
var import_tiny_invariant5 = __toESM(require("tiny-invariant"));
var import_jsbi6 = __toESM(require("jsbi"));
var TokenAmount = class _TokenAmount extends CurrencyAmount {
  // amount _must_ be raw, i.e. in the native representation
  constructor(token, amount) {
    super(token, amount);
    this.token = token;
  }
  add(other) {
    (0, import_tiny_invariant5.default)(this.token.equals(other.token), "TOKEN");
    return new _TokenAmount(this.token, import_jsbi6.default.add(this.raw, other.raw));
  }
  subtract(other) {
    (0, import_tiny_invariant5.default)(this.token.equals(other.token), "TOKEN");
    return new _TokenAmount(this.token, import_jsbi6.default.subtract(this.raw, other.raw));
  }
};

// src/entities/price.ts
var import_tiny_invariant6 = __toESM(require("tiny-invariant"));
var import_jsbi7 = __toESM(require("jsbi"));
var Price = class _Price extends Fraction {
  // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token
  // denominator and numerator _must_ be raw, i.e. in the native representation
  constructor(baseCurrency, quoteCurrency, denominator, numerator) {
    super(numerator, denominator);
    this.baseCurrency = baseCurrency;
    this.quoteCurrency = quoteCurrency;
    this.scalar = new Fraction(
      import_jsbi7.default.exponentiate(TEN, import_jsbi7.default.BigInt(baseCurrency.decimals)),
      import_jsbi7.default.exponentiate(TEN, import_jsbi7.default.BigInt(quoteCurrency.decimals))
    );
  }
  get raw() {
    return new Fraction(this.numerator, this.denominator);
  }
  get adjusted() {
    return super.multiply(this.scalar);
  }
  invert() {
    return new _Price(
      this.quoteCurrency,
      this.baseCurrency,
      this.numerator,
      this.denominator
    );
  }
  multiply(other) {
    (0, import_tiny_invariant6.default)(currencyEquals(this.quoteCurrency, other.baseCurrency), "TOKEN");
    const fraction = super.multiply(other);
    return new _Price(
      this.baseCurrency,
      other.quoteCurrency,
      fraction.denominator,
      fraction.numerator
    );
  }
  // performs floor division on overflow
  quote(currencyAmount) {
    (0, import_tiny_invariant6.default)(
      currencyEquals(currencyAmount.currency, this.baseCurrency),
      "TOKEN"
    );
    if (this.quoteCurrency instanceof Token) {
      return new TokenAmount(
        this.quoteCurrency,
        super.multiply(currencyAmount.raw).quotient
      );
    }
    return CurrencyAmount.ether(
      currencyAmount.currency.chainId,
      super.multiply(currencyAmount.raw).quotient
    );
  }
  toSignificant(significantDigits = 6, format, rounding) {
    return this.adjusted.toSignificant(significantDigits, format, rounding);
  }
  toFixed(decimalPlaces = 4, format, rounding) {
    return this.adjusted.toFixed(decimalPlaces, format, rounding);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CAVAX,
  CNATIVE,
  ChainId,
  CurrencyAmount,
  FIVE,
  Fraction,
  MINIMUM_LIQUIDITY,
  NativeCurrency,
  ONE,
  Percent,
  Price,
  Rounding,
  SOLIDITY_TYPE_MAXIMA,
  SolidityType,
  TEN,
  THREE,
  TWO,
  Token,
  TokenAmount,
  TradeType,
  WAVAX,
  WNATIVE,
  ZERO,
  _100,
  _1000,
  _997,
  currencyEquals,
  parseBigintIsh,
  sortedInsert,
  sqrt,
  validateAndParseAddress,
  validateSolidityTypeInstance
});
